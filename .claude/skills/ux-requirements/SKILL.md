---
name: ux-requirements
description: UI/UX 요구사항을 사용자와 대화형으로 도출하고, 구현 가능한 명세서를 생성하는 스킬. UI 기능 설계, UX 플로우 정의, 컴포넌트 요구사항 정리 요청 시 사용.
---

# UX Requirements 도출 스킬

사용자와 **협업 대화**를 통해 UI/UX 요구사항을 구현 가능한 명세서로 변환합니다.

## 핵심 원칙

1. **사용자는 공동 설계자다** — 선택지만 고르는 게 아니라, 자기 아이디어를 제안하고 AI의 제안을 수정한다.
2. **AI는 기술 자문 역할이다** — 추천안 + 근거 + 트레이드오프를 제시하고, 사용자가 판단한다.
3. **결정할 때마다 즉시 시각화한다** — 하나의 결정이 나오면 바로 와이어프레임에 반영하고 확인받는다.
4. **반복 루프로 수렴한다** — 제안 → 사용자 피드백 → 수정 → 재확인을 결정이 확정될 때까지 반복한다.

---

## Phase 1: 현황 파악

### `/ux-audit` 결과가 있는 경우 (권장)

`/ux-audit`를 먼저 실행했다면, 그 출력물(7가지 관점 분석)을 Phase 1 입력으로 사용한다.
Phase 1을 스킵하고 **바로 Phase 2 갭 분석**으로 진행한다.

### `/ux-audit` 없이 시작하는 경우

사용자가 기능을 설명하면, **사용자에게 질문하기 전에** 먼저 기존 코드를 탐색한다.
`/ux-audit`의 7가지 관점(UX Flow, 제공 정보, CTA, 화면 상태, 데이터 의존성, 피드백, 빈 상태)을
간략하게라도 파악한 후 사용자에게 보고한다.

---

## Phase 2: 갭 분석 + 설계 질문 (AI 제안 → 사용자 판단)

### Step 2-1: 요구사항 갭 분석

사용자의 요구사항 각각을 현재 상태와 대비하여 정리한다.

```markdown
| # | 사용자 요구사항 | 현재 상태 | 갭 | 필요 작업 |
|---|---------------|----------|-----|----------|
| 1 | [원문 그대로] | [코드 기준 현황] | [차이] | [해야 할 일] |
```

### Step 2-2: 설계 질문 (결정 필요 사항)

갭 분석에서 도출된 **결정 필요 사항**을 질문한다.

#### 질문 형식 (필수)

모든 질문은 아래 3요소를 포함한다:

```markdown
**Q1. [질문]**

| 선택지 | 장점 | 단점/제약 |
|--------|------|----------|
| A: [옵션] | [장점] | [단점] |
| B: [옵션] | [장점] | [단점] |
| C: 직접 제안 | 사용자의 아이디어 | - |

💡 내 추천: [A/B] — [추천 근거 1~2문장]
```

#### 질문 규칙

- **한 번에 3~5개** — 핵심 결정만 먼저, 세부 사항은 다음 라운드
- **"직접 제안" 옵션을 항상 포함** — 사용자가 A/B 외의 아이디어를 낼 수 있게 한다
- **추천과 근거를 반드시 밝힌다** — 사용자가 비판적으로 판단할 수 있는 재료를 제공
- **기술 제약을 장단점에 녹인다** — 별도 섹션이 아니라 선택지의 단점으로 표현
- **기술 용어를 사용자 언어로 번역한다** — "polling interval 5초" ❌ → "결과를 5초마다 자동 확인" ✅

---

## Phase 3: 반복 설계 루프 (핵심 — 수렴할 때까지 반복)

Phase 2의 답변을 받은 후, **결정 → 시각화 → 피드백 → 수정** 루프를 돌린다.

### 루프 구조

```
┌─────────────────────────────────────────────────┐
│  1. 사용자 답변 수신                              │
│     ↓                                            │
│  2. 답변 반영하여 와이어프레임 즉시 그림            │
│     ↓                                            │
│  3. 사용자 확인: "이대로?" / "이 부분 수정"         │
│     ↓                                            │
│  4-a. 확정 → 다음 영역으로                        │
│  4-b. 수정 요청 → 와이어프레임 수정 → 3번으로      │
│     ↓                                            │
│  5. 새로운 결정 사항 발생 → 2-2 질문 형식으로 제시  │
│     ↓                                            │
│  (모든 영역 확정될 때까지 반복)                     │
└─────────────────────────────────────────────────┘
```

### 와이어프레임 규칙

- **결정 하나마다 즉시** 해당 부분의 와이어프레임을 그린다 (전체를 한 번에 그리지 않는다)
- 사용자가 수정을 요청하면 **수정된 부분만 다시** 그린다
- 모든 화면 상태를 커버한다:

| 상태 | 필수 여부 |
|------|----------|
| 초기 (데이터 없음) | 필수 |
| 로딩/진행 중 | 비동기 작업이 있으면 필수 |
| 성공 | 필수 |
| 실패/에러 | 필수 |
| 엣지 케이스 (빈 목록, 다수 항목) | 해당되면 필수 |

### 사용자 역제안 처리

사용자가 선택지에 없는 아이디어를 제안하면:

1. **즉시 기술 실현 가능성을 평가**한다 (가능/불가능/조건부 가능)
2. 가능하면 **바로 와이어프레임에 반영**하고 보여준다
3. 제약이 있으면 **제약을 설명하고 대안을 함께 제시**한다
4. 사용자의 아이디어를 기반으로 **발전시킨 버전**을 제안한다

예시:
```
사용자: "toast는 별로야. 그냥 UI가 흔들흔들거리는 건 어떨까?"
→ AI: "CSS shake 애니메이션으로 구현 가능합니다. 카드 전체를 0.5초간
      좌우 흔드는 건 어떤가요? 바로 그려보겠습니다."
→ [즉시 와이어프레임 반영]
```

### 상태 전이표

화면 상태가 2개 이상이면 반드시 정리한다:

```markdown
| 상태 | 트리거 | 다음 상태 | UI 변화 |
|------|--------|----------|---------|
| 초기 | 버튼 클릭 | 로딩 | spinner + disabled |
| 로딩 | 완료 | 성공/실패 | shake + 결과 카드 |
```

---

## Phase 4: 명세서 생성

모든 영역의 와이어프레임이 확정되면 **구현 전달용 명세서**를 생성한다.

### 명세서 필수 섹션

```markdown
## [기능명] UI/UX 구현 지시사항

### API 엔드포인트 (Swagger 기준)
| Method | Path | 용도 | 비고 |
|--------|------|------|------|

### Mock 동작
- [시뮬레이션 방식, 지연, 확률]

### 화면 구성

#### 1. [영역명]
- 설명: [무엇을 보여주는가]
- 데이터: [API/상태 소스]
- 조건: [표시/숨김 조건]
- 와이어프레임: [ASCII]

### 상태별 화면 전환
| 상태 | Primary 버튼 | 진행률 | 결과 영역 |
|------|-------------|--------|----------|

### 기술 제약
- [토큰, 애니메이션, 접근성 등]
```

### 결정 추적표 (명세서 말미에 포함)

대화 중 내린 모든 결정을 기록한다:

```markdown
### 설계 결정 이력
| # | 결정 사항 | 선택 | 근거 | 제안자 |
|---|----------|------|------|--------|
| 1 | 상태 전환 알림 | shake 애니메이션 | toast 대비 맥락 유지 | 사용자 |
| 2 | 결과 카드 기본 상태 | 접힘 | 리소스 20+ 대응 | 사용자 |
| 3 | History 접근 | secondary 버튼 → 모달 | 메인 뷰 단순화 | AI 추천 |
```

### 품질 체크리스트

- [ ] 모든 화면 상태가 와이어프레임으로 표현되었는가?
- [ ] 모든 버튼/액션의 동작이 명시되었는가?
- [ ] 로딩/에러/빈 상태가 모두 정의되었는가?
- [ ] API와 데이터 흐름이 명시되었는가?
- [ ] 사용자의 모든 결정이 반영되었는가?
- [ ] 기술 제약이 명시되었는가?
- [ ] 애니메이션/전환 효과가 구체적으로 기술되었는가?
- [ ] 결정 추적표가 완성되었는가?

---

## 디자인 원칙 (이 프로젝트 기준)

### 정보 계층

1. **왜 해야 하는지** 먼저 설명한다 (액션의 목적과 효과)
2. **현재 상태**를 명확히 보여준다 (마지막 성공/실패, 이력 유무)
3. **주요 액션**은 Primary 1개, **보조 탐색**은 Secondary 또는 텍스트 링크
4. **상세 정보**는 접힌 상태가 기본, 사용자가 원할 때 펼침

### 피드백 우선순위

| 순위 | 방식 | 용도 |
|------|------|------|
| 1 | 인라인 UI 변화 (텍스트, 뱃지, 색상) | 상태 전환, 진행률 |
| 2 | 애니메이션 (shake, pulse) | 완료 알림, 주의 환기 |
| 3 | 배너/카드 | 결과 요약, 에러 안내 |
| 4 | 모달 | 상세 이력, 리소스별 결과 |
| 5 | Toast | 사용 지양 — 맥락에서 분리됨 |

### 버튼 규칙

| 유형 | 용도 | 구현 |
|------|------|------|
| Primary | 화면당 핵심 액션 1개 | `getButtonClass('primary')` |
| Secondary | 보조 액션, 탐색 ("확인하러 가기") | `getButtonClass('secondary')` |
| Danger | 삭제, 위험 작업 | `getButtonClass('danger')` |
| Text Link | 네비게이션, 부가 정보 접근 | `primaryColors.text` + hover underline |

### 비동기 작업 표현

| 예상 소요 | 표현 방식 |
|-----------|----------|
| 5초 미만 | spinner (버튼 내부) |
| 5초 이상 | progress bar + 진행률 텍스트 ("3/7 완료") |
| 상태 전환 시 | 카드 shake 애니메이션 (0.5초) |
| 완료 후 | 결과 카드 (접힌 상태 기본, 펼침 버튼 제공) |

---

## Anti-patterns

| 금지 | 대신 |
|------|------|
| 사용자 확인 없이 디자인 결정 | 추천 + 근거를 제시하고 사용자가 판단 |
| 선택지 A/B만 제시 | 항상 "직접 제안" 옵션 포함 |
| 추천 근거 없이 "A가 좋겠습니다" | "A 추천 — [구체적 이유]" |
| 전체 와이어프레임을 한 번에 | 결정마다 해당 영역만 즉시 시각화 |
| 사용자 역제안 무시 | 기술 실현성 즉시 평가 + 발전 제안 |
| 말로만 합의 | 반드시 와이어프레임으로 시각 확인 |
| 모호한 표현 ("적절히 표시") | 구체적 토큰 ("statusColors.error.textDark") |
| 기술 용어로 질문 ("polling interval?") | 사용자 언어 ("결과를 5초마다 자동 확인?") |
| 엣지 케이스 무시 | 빈 상태, 에러, 다수 항목 반드시 정의 |
